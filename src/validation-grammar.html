<section class="appendix">
   <h2 id="cmvg">Content Markup Validation Grammar</h2>
   
   
   
   
   <div class="issue" id="update_content_grammar"><span class="head">Update Content Grammar</span>
      
      
      <p>The current appendix describes MathML2, it will need to be updated in later drafts.</p>
      </div>
   
   
   <div class="issue" id="content_grammar_relax"><span class="head">Content Grammar relax NG</span>
      
      
      <p>With small syntax changes the EBNF presented here could be viewed as a Relax NG schema,
         should
         the working group support such a schema?</p>
      </div>
   
   
   
   <p>This presents an informal EBNF grammar that can be used to validate the structure
      of Content Markup.</p>
   
   
   
   <slist>
      
      <sitem>It defines the valid expression trees in content markup.
         It does not define the rules for attribute validation.  That must be done separately.</sitem>
      
      
      <sitem>The non-terminal 
         <nt def="Presentation.tags">Presentation_tags</nt> is a placeholder for a valid
         presentation element start tag or end tag.</sitem>
      
      
      <sitem>The string <code>#PCDATA</code> denotes XML parsed character data.</sitem>
      
      
      <sitem>Symbols beginning with '_' (for example 
         <nt def="nt.mmlarg">_mmlarg</nt>) are internal symbols.
         A recursive grammar is usually required for their recognition.</sitem>
      
      
      <sitem>Symbols which are all in lowercase symbols (for example 'ci') are terminal symbols
         representing MathML content elements.</sitem>
      
      
      <sitem>Symbols beginning with Uppercase letters are terminals representating other tokens.</sitem>
      
      
      </slist>
   
   
   <scrap>
      
      
      
      <prod id="Presentation.tags">
         
         <lhs>Presentation_tags</lhs>
         
         <rhs> "presentation"</rhs>
         
         <com>placeholder</com>
         </prod>
      
      
      <prod id="pSpace">
         
         <lhs>Space</lhs>
         
         <rhs> #x09 | #x0A | #x0D | #x20</rhs>
         
         <com>tab, lf, cr, space characters</com>
         </prod>
      
      
      <prod id="pS">
         
         <lhs>S</lhs>
         
         <rhs> (
            <nt def="pSpace">Space</nt> | 
            <nt def="Presentation.tags">Presentation_tags"</nt>)*</rhs>
         
         <com>treat presentation as space</com>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="pChar">
         
         <lhs>Char</lhs>
         
         <rhs>#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]</rhs>
         
         <com>valid XML chars</com>
         </prod>
      </scrap>
   
   
   
   <slist>
      
      <sitem>start(\%x) returns a valid start tag for the element \%x</sitem>
      
      <sitem>end(\%x) returns a valid end tag for the element \%x</sitem>
      
      <sitem>empty(\%x) returns a valid empty tag for the element \%x</sitem>
      </slist>
   
   
   <pre>
 start(ci)    ::= "&lt;ci&gt;"
 end(cn)      ::= "&lt;/cn&gt;"
 empty(plus)  ::= "&lt;plus/&gt;"
</pre>
   
   
   <p>The reason for doing this is to avoid writing a grammar
      for all the attributes. The model below is not complete
      for all possible attribute values.</p>
   
   
   
   <scrap>
      
      
      
      <prod id="nt.start">
         
         <lhs>_start(\%x)</lhs>
         
         <rhs> "&lt;\%x" (
            <nt def="pChar">Char</nt> - '&gt;')* "&gt;"</rhs>
         
         <com> returns a valid start tag for the element \%x</com>
         </prod>
      
      
      <prod id="nt.end">
         
         <lhs>_end(\%x)</lhs>
         
         <rhs> "&lt;\%x" 
            <nt def="pSpace">Space</nt>* "&gt;"</rhs>
         
         <com> returns a valid end tag for the element \%x</com>
         </prod>
      
      
      <prod id="nt.empty">
         
         <lhs>_empty(\%x)</lhs>
         
         <rhs> "&lt;\%x" (
            <nt def="pChar">Char</nt> - '&gt;')* "/&gt;"</rhs>
         
         <com> returns a valid empty tag for the element \%x</com>
         </prod>
      
      
      <prod id="nt.sg">
         
         <lhs>_sg(\%x)</lhs>
         
         <rhs> 
            <nt def="pS">S</nt> 
            <nt def="nt.start">_start</nt>(\%x)</rhs>
         
         <com> start tag preceded by optional whitespace</com>
         </prod>
      
      
      <prod id="nt.eg">
         
         <lhs>_eg(\%x)</lhs>
         
         <rhs> 
            <nt def="nt.end">_end</nt>(\%x) 
            <nt def="pS">S</nt>
         </rhs>
         
         <com> end tag followed by optional whitespace</com>
         </prod>
      
      
      <prod id="nt.ey">
         
         <lhs>_ey(\%x)</lhs>
         
         <rhs> 
            <nt def="pS">S</nt> 
            <nt def="nt.empty">_empty</nt>(\%x) 
            <nt def="pS">S</nt>
         </rhs>
         
         <com> empty tag preceded and followed by optional whitespace</com>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="psemantics">
         
         <lhs>semantics</lhs>
         
         <rhs>
            
            <nt def="nt.sg">_sg</nt>(semantics)
            
            <nt def="nt.mmlarg">_mmlarg</nt>
            
            <nt def="nt.annot">_annot</nt>*
            
            <nt def="nt.eg">_eg</nt>(semantics)
            </rhs>
         </prod>
      
      
      <prod id="pannotation">
         
         <lhs>annotation</lhs>
         
         <rhs>
            
            <nt def="nt.sg">_sg</nt>(annotation)
            #PCDATA
            
            <nt def="nt.eg">_eg</nt>(annotation)
            </rhs>
         </prod>
      
      
      <prod id="pannotation-xml">
         
         <lhs>annotation-xml</lhs>
         
         <rhs>
            
            <nt def="nt.sg">_sg</nt>(annotation-xml)
            
            <nt def="nt.ANY">_ANY</nt>
            
            <nt def="nt.eg">_eg</nt>(annotation-xml)
            </rhs>
         </prod>
      
      
      <prod id="nt.ANY">
         
         <lhs>_ANY</lhs>
         
         <rhs>"AnyXML"</rhs>
         
         <com>placeholder for wellformed XML Fragment (not Mixed Content)</com>
         </prod>
      
      
      <prod id="nt.annot">
         
         <lhs>_annot</lhs>
         
         <rhs> annotation | annotation-xml </rhs>
         </prod>
      </scrap>
   
   
   
   
   <scrap>
      
      
      
      <prod id="nt.mmlarg">
         
         <lhs>_mmlarg</lhs>
         
         
         <rhs> 
            <nt def="nt.container">_container</nt> | 
            <nt def="nt.token">_token</nt> | 
            <nt def="nt.operator">_operator</nt> | 
            <nt def="nt.relation">_relation</nt> </rhs>
         </prod>
      
      
      <prod id="nt.container">
         
         <lhs>_container</lhs>
         
         
         <rhs> 
            <nt def="nt.special">_special</nt> | 
            <nt def="nt.constructor">_constructor</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.token">
         
         <lhs>_token</lhs>
         
         <rhs> ci | cn | csymbol | 
            <nt def="nt.constantsym">_constantsym</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.special">
         
         <lhs>_special</lhs>
         
         <rhs> apply | lambda | reln | fn | semantics</rhs>
         </prod>
      
      
      <prod id="nt.constructor">
         
         <lhs>_constructor</lhs>
         
         <rhs> interval | list | matrix | matrixrow | set | vector	| piecewise
            | piece | otherwise</rhs>
         </prod>
      
      
      
      <prod id="nt.qualifier">
         
         <lhs>_qualifier</lhs>
         
         
         <rhs> lowlimit | uplimit | degree | logbase | domainofapplication
            | momentabout | condition </rhs>
         <com>interval is both a qualifier and a constructor</com>
         </prod>
      
      
      <prod id="nt.constantsym">
         
         <lhs>_constantsym</lhs>
         
         <rhs> integers | rationals | reals | naturalnumbers | complexes | primes 
            | exponentiale | imaginaryi | notanumber | true | false | pi
            | eulergamma | infinity</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.relation">
         
         <lhs>_relation</lhs>
         
         <rhs> 
            <nt def="nt.genrel">_genrel</nt> | 
            <nt def="nt.setrel">_setrel</nt> | 
            <nt def="nt.seqrel2ary">_seqrel2ary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.genrel">
         
         <lhs>_genrel</lhs>
         
         <rhs> 
            <nt def="nt.genrel2ary">_genrel2ary</nt> | 
            <nt def="nt.genrelnary">_genrelnary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.genrel2ary">
         
         <lhs>_genrel2ary</lhs>
         
         <rhs> ne</rhs>
         </prod>
      
      
      <prod id="nt.genrelnary">
         
         <lhs>_genrelnary</lhs>
         
         <rhs> eq | leq | lt | geq | gt</rhs>
         </prod>
      
      
      <prod id="nt.setrel">
         
         <lhs>_setrel</lhs>
         
         <rhs>  
            <nt def="nt.seqrel2ary">_seqrel2ary</nt> | 
            <nt def="nt.setrelnary">_setrelnary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.setrel2ary">
         
         <lhs>_setrel2ary</lhs>
         
         <rhs>  in | notin | notsubset | notprsubset</rhs>
         </prod>
      
      
      <prod id="nt.setrelnary">
         
         <lhs>_setrelnary</lhs>
         
         <rhs> subset | prsubset</rhs>
         </prod>
      
      
      <prod id="nt.seqrel2ary">
         
         <lhs>_seqrel2ary</lhs>
         
         <rhs> tendsto</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.operator">
         
         <lhs>_operator</lhs>
         
         <rhs> 
            <nt def="nt.funcop">_funcop</nt> |
            
            <nt def="nt.arithop">_arithop</nt> | 
            <nt def="nt.calcop">_calcop</nt> | 
            
            <nt def="nt.vcalcop">_vcalcop</nt> | 
            <nt def="nt.seqop">_seqop</nt> |
            
            <nt def="nt.trigop">_trigop</nt> | 
            <nt def="nt.classop">_classop</nt> |
            
            <nt def="nt.statop">_statop</nt> | 
            <nt def="nt.lalgop">_lalgop</nt> |
            
            <nt def="nt.logicop">_logicop</nt> | 
            <nt def="nt.setop">_setop</nt>
         </rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.funcop">
         
         <lhs>_funcop</lhs>
         
         <rhs> 
            <nt def="nt.funcop1ary">_funcop1ary</nt> | 
            <nt def="nt.funcopnary">_funcopnary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.funcop1ary">
         
         <lhs>_funcop1ary</lhs>
         
         <rhs> inverse     | ident | domain | codomain | image</rhs>
         </prod>
      
      
      <prod id="nt.funcopnary">
         
         <lhs>_funcopnary</lhs>
         
         <rhs> fn| compose</rhs>
         
         <com> general user-defined function is n-ary</com>
         </prod>
      </scrap>
   
   
   <p>(note <code class="element">minus</code> is both 1ary and 2ary)</p>
   
   
   <scrap>
      
      
      
      <prod id="nt.arithop">
         
         <lhs>_arithop</lhs>
         
         <rhs> 
            <nt def="nt.arithop1ary">_arithop1ary</nt> | 
            <nt def="nt.arithop2ary">_arithop2ary</nt> | 
            <nt def="nt.arithopnary">_arithopnary</nt>  | root</rhs>
         </prod>
      
      
      <prod id="nt.arithop1ary">
         
         <lhs>_arithop1ary</lhs>
         
         <rhs> abs | conjugate | factorial | minus | arg | real | imaginary
            | floor | ceiling</rhs>
         </prod>
      
      
      <prod id="nt.arithop2ary">
         
         <lhs>_arithop2ary</lhs>
         
         <rhs> quotient | divide | minus | power | rem</rhs>
         </prod>
      
      
      <prod id="nt.arithopnary">
         
         <lhs>_arithopnary</lhs>
         
         <rhs> plus | times | max | min | gcd | lcm</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.calcop">
         
         <lhs>_calcop</lhs>
         
         <rhs> int | diff | partialdiff</rhs>
         </prod>
      
      
      <prod id="nt.vcalcop">
         
         <lhs>_vcalcop</lhs>
         
         <rhs> divergence | grad | curl | laplacian</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.seqop">
         
         <lhs>_seqop</lhs>
         
         <rhs> sum | product | limit</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.classop">
         
         <lhs>_classop</lhs>
         
         <rhs> exp | ln | log</rhs>
         </prod>
      
      <prod id="nt.trigop">
         
         <lhs>_trigop</lhs>
         
         <rhs> sin | cos | tan | sec | csc | cot | sinh 
            | cosh | tanh | sech | csch | coth 
            | arcsin | arccos | arctan</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.statop">
         
         <lhs>_statop</lhs>
         
         <rhs> 
            <nt def="nt.statopnary">_statopnary</nt> | moment</rhs>
         </prod>
      
      
      <prod id="nt.statopnary">
         
         <lhs>_statopnary</lhs>
         
         <rhs> mean | sdev | variance | median | mode</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.lalgop">
         
         <lhs>_lalgop</lhs>
         
         <rhs> 
            <nt def="nt.lalgop1ary">_lalgop1ary</nt> |
            <nt def="nt.lalgop2ary">_lalgop2ary</nt> | 
            <nt def="nt.lalgopnary">_lalgopnary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.lalgop1ary">
         
         <lhs>_lalgop1ary</lhs>
         
         <rhs> determinant | transpose</rhs>
         </prod>
      
      
      <prod id="nt.lalgop2ary">
         
         <lhs>_lalgop2ary</lhs>
         
         <rhs> vectorproduct | scalarproduct | outerproduct</rhs>
         </prod>
      
      
      <prod id="nt.lalgopnary">
         
         <lhs>_lalgopnary</lhs>
         
         <rhs> selector</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.logicop">
         
         <lhs>_logicop</lhs>
         
         <rhs> 
            <nt def="nt.logicop1ary">_logicop1ary</nt>
            | 
            <nt def="nt.logicopnary">_logicopnary</nt>
            | 
            <nt def="nt.logicop2ary">_logicop2ary</nt>
            | 
            <nt def="nt.logicopquant">_logicopquant</nt>
            </rhs>
         </prod>
      
      
      <prod id="nt.logicop1ary">
         
         <lhs>_logicop1ary</lhs>
         
         <rhs> not</rhs>
         </prod>
      
      
      <prod id="nt.logicop2ary">
         
         <lhs>_logicop2ary</lhs>
         
         <rhs> implies	| equivalent | approx | factorof</rhs>
         </prod>
      
      
      <prod id="nt.logicopnary">
         
         <lhs>_logicopnary</lhs>
         
         <rhs> and | or | xor</rhs>
         </prod>
      
      
      <prod id="nt.logicopquant">
         
         <lhs>_logicopquant</lhs>
         
         <rhs> forall | exists</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.setop">
         
         <lhs>_setop</lhs>
         
         <rhs> 
            <nt def="nt.setop1ary">_setop1ary</nt> |
            <nt def="nt.setop2ary">_setop2ary</nt> | 
            <nt def="nt.setopnary">_setopnary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.setop1ary">
         
         <lhs>_setop1ary</lhs>
         
         <rhs> card</rhs>
         </prod>
      
      
      <prod id="nt.setop2ary">
         
         <lhs>_setop2ary</lhs>
         
         <rhs> setdiff</rhs>
         </prod>
      
      
      <prod id="nt.setopnary">
         
         <lhs>_setopnary</lhs>
         
         <rhs> union | intersect | cartesianproduct</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      <prod id="nt.unaryop">
         
         <lhs>_unaryop</lhs>
         
         <rhs>  
            <nt def="nt.funcop1ary">_funcop1ary</nt>
            | 
            <nt def="nt.arithop1ary">_arithop1ary</nt>
            		 | 
            <nt def="nt.trigop">_trigop</nt>
            		 | 
            <nt def="nt.classop">_classop</nt>  
            		 | 
            <nt def="nt.calcop">_calcop</nt>
            		 | 
            <nt def="nt.vcalcop">_vcalcop</nt>
            		 | 
            <nt def="nt.logicop1ary">_logicop1ary</nt>
            		 | 
            <nt def="nt.lalgop1ary">_lalgop1ary</nt>
            		 | 
            <nt def="nt.setop1ary">_setop1ary</nt>
            	       </rhs>
         </prod>
      
      
      <prod id="nt.binaryop">
         
         <lhs>_binaryop</lhs>
         
         <rhs>  
            <nt def="nt.arithop2ary">_arithop2ary</nt> | 
            <nt def="nt.setop2ary">_setop2ary</nt> | 
            <nt def="nt.logicop2ary">_logicop2ary</nt> | 
            <nt def="nt.lalgop2ary">_lalgop2ary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.naryop">
         
         <lhs>_naryop</lhs>
         
         <rhs>  
            <nt def="nt.arithopnary">_arithopnary</nt> | 
            <nt def="nt.statopnary">_statopnary</nt>  | 
            <nt def="nt.logicopnary">_logicopnary</nt> 
            | 
            <nt def="nt.lalgopnary">_lalgopnary</nt> | 
            <nt def="nt.setopnary">_setopnary</nt> | 
            <nt def="nt.funcopnary">_funcopnary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.specialop">
         
         <lhs>_specialop</lhs>
         
         <rhs> 
            <nt def="nt.special">_special</nt> | ci | csymbol </rhs>
         </prod>
      
      
      <prod id="nt.ispop">
         
         <lhs>_ispop</lhs>
         
         <rhs> int | sum | product</rhs>
         </prod>
      
      
      <prod id="nt.diffop">
         
         <lhs>_diffop</lhs>
         
         <rhs> diff | partialdiff</rhs>
         </prod>
      
      
      <prod id="nt.binaryrel">
         
         <lhs>_binaryrel</lhs>
         
         <rhs> 
            <nt def="nt.genrel2ary">_genrel2ary</nt> | 
            <nt def="nt.setrel2ary">_setrel2ary</nt> |  
            <nt def="nt.seqrel2ary">_seqrel2ary</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.naryrel">
         
         <lhs>_naryrel</lhs>
         
         <rhs> 
            <nt def="nt.genrelnary">_genrelnary</nt> | 
            <nt def="nt.setrelnary">_setrelnary</nt>
         </rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="psep">
         
         <lhs>sep</lhs>
         
         <rhs>  
            <nt def="nt.ey">_ey</nt>(sep)</rhs>
         </prod>
      </scrap>
   
   
   
   <scrap>
      
      
      
      <prod id="nt.mdatai">
         
         <lhs>_mdatai</lhs>
         
         <rhs> (#PCDATA | 
            <nt def="Presentation.tags">Presentation_tags</nt>)*</rhs>
         
         <com>note _mdata includes Presentation constructs here.</com>
         </prod>
      
      
      <prod id="nt.mdatan">
         
         <lhs>_mdatan</lhs>
         
         <rhs> (#PCDATA | sep | 
            <nt def="Presentation.tags">Presentation_tags</nt>)*</rhs>
         
         <com>note _mdata includes Presentation constructs here.</com>
         </prod>
      
      
      <prod id="pci">
         
         <lhs>ci</lhs>
         
         <rhs>  
            <nt def="nt.sg">_sg</nt>(ci) 
            <nt def="nt.mdatai">_mdatai</nt> 
            <nt def="nt.eg">_eg</nt>(ci)</rhs>
         </prod>
      
      
      <prod id="pcn">
         
         <lhs>cn</lhs>
         
         <rhs>  
            <nt def="nt.sg">_sg</nt>(cn) 
            <nt def="nt.mdatan">_mdatan</nt> 
            <nt def="nt.eg">_eg</nt>(cn)</rhs>
         </prod>
      
      
      <prod id="pcsymbol">
         
         <lhs>csymbol</lhs>
         
         <rhs>  
            <nt def="nt.sg">_sg</nt>(csymbol) 
            <nt def="nt.mdatai">_mdatai</nt> 
            <nt def="nt.eg">_eg</nt>(csymbol)</rhs>
         </prod>
      </scrap>
   
   
   <p>
      <code class="element">condition</code> -  constraints.
      constraints contains either a single <code class="element">reln</code> (relation), or
      an apply holding a logical combination of relations, or
      a set (over which the operator should be applied).</p>
   
   <scrap>
      
      
      
      <prod id="pcondition">
         
         <lhs>condition</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(condition)  reln | apply | set  
            <nt def="nt.eg">_eg</nt>(condition)</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      
      <prod id="nt.domainofapp">
         
         <lhs>_domainofapp</lhs>
         
         <rhs> domainofapplication | 
            <nt def="nt.domainabbrev">_domainabbrev</nt>
         </rhs>
         </prod>
      
      
      <prod id="nt.domainabbrev">
         
         <lhs>_domainabbrev</lhs>
         
         <rhs> (lowlimit  uplimit?)
            | uplimit
            | interval
            | condition</rhs>
         </prod>
      </scrap>
   
   
   <p>
      Note that <code class="element">apply</code> is used in place of the deprecated <code class="element">reln</code> in MathML2.0
      for relational operators as well as arithmetic, algebraic etc.</p>
   
   
   <scrap>
      
      
      
      <prod id="papply">
         
         <lhs>apply</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(apply) 
            <nt def="nt.applybody">_applybody</nt> | 
            <nt def="nt.relnbody">_relnbody</nt> 
            <nt def="nt.eg">_eg</nt>(apply)</rhs>
         </prod>
      
      
      <prod id="nt.applybody">
         
         <lhs>_applybody</lhs>
         
         <rhs>( 
            <nt def="nt.unaryop">_unaryop</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt>  )</rhs>
         
         <com>1-ary ops</com>
         
         <rhs>| (
            <nt def="nt.binaryop">_binaryop</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>2-ary ops</com>
         
         <rhs>| (
            <nt def="nt.naryop">_naryop</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt>*)</rhs>
         
         <com>n-ary ops, enumerated arguments</com>
         
         
         
         <rhs>| (
            <nt def="nt.naryop">_naryop</nt> bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt>? 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>n-ary ops, over domain of application</com>
         
         <rhs>| (
            <nt def="nt.specialop">_specialop</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt>*)</rhs>
         
         <com>special ops can be applied to anything</com>
         
         <rhs>| (
            <nt def="nt.specialop">_specialop</nt> bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt>? 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>special ops, over domain of application </com>
         
         
         
         
         
         <rhs>| (
            <nt def="nt.ispop">_ispop</nt>  bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt>? 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>integral, sum, product</com>
         
         <rhs>| (
            <nt def="nt.diffop">_diffop</nt> bvar* 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>differential ops</com>
         
         <rhs>| (log logbase? 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>logs</com>
         
         <rhs>| (moment degree? momentabout? 
            <nt def="nt.mmlarg">_mmlarg</nt>*)</rhs>
         
         <com>statistical moment</com>
         
         <rhs>| (root degree? 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>radicals - default is square-root</com>
         
         <rhs>| (limit bvar* lowlimit? condition? 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>limits</com>
         
         
         
         <rhs>| (
            <nt def="nt.logicopquant">_logicopquant</nt> bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt>? 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         
         <com>quantifier with explicit bound variables</com>
         </prod>
      </scrap>    
   
   
   <p>
      Equations and relations - <code class="element">reln</code> uses lisp-like syntax (like <code class="element">apply</code>)
      the <code class="element">bvar</code> and <code class="element">condition</code> elements are used to construct a "such that" or
      "where" constraint on the relation. 
      Note that <code class="element">reln</code> is deprecated but still valid in MathML2.0.</p>
   
   
   <scrap>
      
      
      
      <prod id="preln">
         
         <lhs>reln</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(reln) 
            <nt def="nt.relnbody">_relnbody</nt> 
            <nt def="nt.eg">_eg</nt>(reln)</rhs>
         </prod>
      
      
      <prod id="nt.relnbody">
         
         <lhs>_relnbody</lhs>
         
         <rhs> ( 
            <nt def="nt.binaryrel">_binaryrel</nt> bvar* condition? 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt> )
            | ( 
            <nt def="nt.naryrel">_naryrel</nt> bvar* condition? 
            <nt def="nt.mmlarg">_mmlarg</nt>*  )</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="pfn">
         
         <lhs>fn</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(fn) 
            <nt def="nt.fnbody">_fnbody</nt> 
            <nt def="nt.eg">_eg</nt>(fn)</rhs>
         </prod>
      
      
      <prod id="nt.fnbody">
         
         <lhs>_fnbody</lhs>
         
         
         <rhs>  
            <nt def="Presentation.tags">Presentation_tags</nt> | 
            <nt def="nt.mmlarg">_mmlarg</nt>
         </rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="plambda">
         
         <lhs>lambda</lhs>
         
         <rhs>  
            <nt def="nt.sg">_sg</nt>(lambda) 
            <nt def="nt.lambdabody">_lambdabody</nt> 
            <nt def="nt.eg">_eg</nt>(lambda)</rhs>
         </prod>
      
      
      <prod id="nt.lambdabody">
         
         <lhs>_lambdabody</lhs>
         
         
         <rhs>  bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt>? 
            <nt def="nt.mmlarg">_mmlarg</nt>
         </rhs>
         
         <com>multivariate lambda calculus</com>
         </prod>
      </scrap>
   
   
   
   <scrap>
      
      
      
      <prod id="pinterval">
         
         <lhs>interval</lhs>
         
         <rhs>  
            <nt def="nt.sg">_sg</nt>(interval) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(interval)</rhs>
         
         <com>start, end define interval</com>
         </prod>
      
      
      <prod id="pset">
         
         <lhs>set</lhs>
         
         <rhs>  
            <nt def="nt.sg">_sg</nt>(set) 
            <nt def="nt.lsbody">_lsbody</nt> 
            <nt def="nt.eg">_eg</nt>(set)</rhs>
         </prod>
      
      
      <prod id="plist">
         
         <lhs>list</lhs>
         
         <rhs>  
            <nt def="nt.sg">_sg</nt>(list) 
            <nt def="nt.lsbody">_lsbody</nt> 
            <nt def="nt.eg">_eg</nt>(list)</rhs>
         </prod>
      
      
      <prod id="nt.lsbody">
         
         <lhs>_lsbody</lhs>
         
         <rhs>  
            <nt def="nt.mmlarg">_mmlarg</nt>*</rhs>
         <com>enumerated arguments</com>
         
         
         <rhs>| (bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt>)</rhs>
         <com>generated arguments</com>
         </prod>
      
      
      <prod id="pmatrix">
         
         <lhs>matrix</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(matrix) matrixrow* 
            <nt def="nt.eg">_eg</nt>(matrix)</rhs>
         
         <rhs>| 
            <nt def="nt.sg">_sg</nt>(matrix) bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt>? 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(matrix)</rhs>
         
         <com>vectors over domain of application</com>
         </prod>
      
      
      <prod id="pmatrixrow">
         
         <lhs>matrixrow</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(matrixrow) 
            <nt def="nt.mmlarg">_mmlarg</nt>* 
            <nt def="nt.eg">_eg</nt>(matrixrow)</rhs>
         
         <com>allows matrix of operators</com>
         </prod>
      
      
      <prod id="pvector">
         
         <lhs>vector</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(vector) 
            <nt def="nt.mmlarg">_mmlarg</nt>* 
            <nt def="nt.eg">_eg</nt>(vector)</rhs>
         
         <rhs>| 
            <nt def="nt.sg">_sg</nt>(vector) bvar* 
            <nt def="nt.domainofapp">_domainofapp</nt>? 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(vector)</rhs>
         
         <com>vectors over domain of application</com>
         </prod>
      
      
      <prod id="ppiecewise">
         
         <lhs>piecewise</lhs>
         
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(piecewise) piece* otherwise? 
            <nt def="nt.eg">_eg</nt>(piecewise)</rhs>
         </prod>
      
      
      <prod id="ppiece">
         
         <lhs>piece</lhs>
         
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(piece) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(piece)</rhs>
         
         <com>used by piecewise</com>
         </prod>
      
      
      <prod id="potherwise">
         
         <lhs>otherwise</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(otherwise) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(otherwise)</rhs>
         
         <com>used by piecewise</com>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="nt.cisemantics">
         
         <lhs>_cisemantics</lhs>
         
         <rhs>
            
            <nt def="nt.sg">_sg</nt>(semantics)
            
            <nt def="nt.citoken">_citoken</nt>
            
            <nt def="nt.annot">_annot</nt>*
            
            <nt def="nt.eg">_eg</nt>(semantics)
            </rhs>
         </prod>
      
      
      <prod id="nt.citoken">
         
         <lhs>_citoken</lhs>
         
         <rhs> ci |    
            <nt def="nt.cisemantics">_cisemantics</nt>
         </rhs>
         </prod>
      
      
      <prod id="pbvar">
         
         <lhs>bvar</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(bvar) 
            <nt def="nt.citoken">_citoken</nt> degree? 
            <nt def="nt.eg">_eg</nt>(bvar)</rhs>
         </prod>
      
      
      <prod id="pdegree">
         
         <lhs>degree</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(degree) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(degree)</rhs>
         </prod>
      </scrap>
   
   
   <scrap>
      
      
      
      <prod id="plowlimit">
         
         <lhs>lowlimit</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(lowlimit) 
            <nt def="nt.mmlarg">_mmlarg</nt>  
            <nt def="nt.eg">_eg</nt>(lowlimit)</rhs>
         </prod>
      
      
      <prod id="puplimit">
         
         <lhs>uplimit</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(uplimit) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(uplimit)</rhs>
         </prod>
      
      
      <prod id="plogbase">
         
         <lhs>logbase</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(logbase) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(logbase)</rhs>
         </prod>
      
      
      <prod id="pdomainofapplication">
         
         <lhs>domainofapplication</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(domainofapplication) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(domainofapplication)</rhs>
         </prod>
      
      
      <prod id="pmomentabout">
         
         <lhs>momentabout</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(momentabout) 
            <nt def="nt.mmlarg">_mmlarg</nt> 
            <nt def="nt.eg">_eg</nt>(momentabout)</rhs>
         </prod>
      </scrap>
   
   
   
   <p>The top level <code class="element">math</code> element.</p>
   
   <scrap>
      
      
      <prod id="pmath">
         
         <lhs>math</lhs>
         
         <rhs> 
            <nt def="nt.sg">_sg</nt>(math) 
            <nt def="nt.mmlarg">_mmlarg</nt>* 
            <nt def="nt.eg">_eg</nt>(math)</rhs>
         </prod>
      </scrap>
   
   </section>